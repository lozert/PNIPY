
@startuml

' Определение классов Пользователь и его подклассов
class Пользователь {
    -логин: String
    -пароль: String
    -роль: String
    +войти(): void
    +выйти(): void
}

class Студент {
    -записиНаКурсы: List<Курс>
    -успеваемость: List<Оценка>
    -посещаемость: Map<Занятие, Boolean>
    +записатьсяНаКурс(курс: Курс): void
}
Студент --|> Пользователь

class Преподаватель {
    -курсы: List<Курс>
    +добавитьОценку(оценка: Оценка): void
    +обновитьЖурнал(занятие: Занятие): void
}
Преподаватель --|> Пользователь

class Администратор {
    +создатьПользователя(): Пользователь
    +удалитьПользователя(пользователь: Пользователь): void
}
Администратор --|> Пользователь

' Factory Method для создания пользователей
abstract class ПользовательФабрика {
    +создатьПользователя(тип: String): Пользователь
}
class КонкретнаяПользовательФабрика {
    +создатьПользователя(тип: String): Пользователь
}
ПользовательФабрика <|-- КонкретнаяПользовательФабрика

' Классы, связанные с курсами
class Курс {
    -название: String
    -преподаватель: Преподаватель
    -занятия: List<Занятие>
    +вычислитьИтоговуюОценку(стратегия: ОценкаСтратегия): Оценка
}
Пользователь --|> Курс : "может участвовать в"

class Занятие {
    -дата: Date
    -время: Time
    -место: String
    -участники: List<Студент>
}
Курс --> Занятие : "содержит"

class Лекция
Лекция --|> Занятие
class ЛабораторнаяРабота
ЛабораторнаяРабота --|> Занятие

class Экзамен {
    -тип: String
}
Экзамен --|> Занятие

class Группа {
    -студенты: List<Студент>
    +добавитьПодгруппу(группа: Группа): void
}
Группа *-- Группа : "подгруппы"
Группа --> Курс : "проходит"

class Расписание {
    -занятия: List<Занятие>
    +добавитьЗанятие(занятие: Занятие): void
    +удалитьЗанятие(занятие: Занятие): void
}
' Singleton для класса Расписание
class РасписаниеInstance {
    -instance: Расписание
    +getInstance(): Расписание
}
РасписаниеInstance --|> Расписание
Расписание --> Занятие : "управляет"

' Стратегия для итоговой оценки
interface ОценкаСтратегия {
    +вычислить(оценки: List<Оценка>): Оценка
}
class СреднийБаллСтратегия
СреднийБаллСтратегия --|> ОценкаСтратегия
class МаксимальнаяОценкаСтратегия
МаксимальнаяОценкаСтратегия --|> ОценкаСтратегия

Курс --> ОценкаСтратегия : "использует"

' Класс Оценка
class Оценка {
    -значение: int
    -тип: String
    +получитьВес(): float
}
Курс --> Оценка : "формирует"

' Декоратор для Оценка
class ОценкаДекоратор {
    -оценка: Оценка
    +получитьВес(): float
}
ОценкаДекоратор --|> Оценка

' Журнал
class Журнал {
    -записи: Map<Занятие, Map<Студент, Оценка>>
}
Курс --> Журнал : "ведет"

' Уведомления (Observer)
interface Наблюдатель {
    +обновить(сообщение: String): void
}
class СтудентНаблюдатель
СтудентНаблюдатель --|> Наблюдатель
class ПреподавательНаблюдатель
ПреподавательНаблюдатель --|> Наблюдатель

class Уведомление {
    -наблюдатели: List<Наблюдатель>
    +добавитьНаблюдателя(наблюдатель: Наблюдатель): void
    +уведомить(сообщение: String): void
}
Расписание --> Уведомление : "генерирует"
Уведомление --> Наблюдатель : "уведомляет"

' Proxy для ограничения доступа
interface ДоступККурсу {
    +получитьДанные(): String
}
class ПроксиКурс {
    -реальныйКурс: Курс
    +получитьДанные(): String
}
ПроксиКурс --|> ДоступККурсу
ПроксиКурс --> Курс : "ограничивает доступ"

' Отчеты (Template Method)
abstract class Отчет {
    +создатьОтчет(): void
    +добавитьДанные(): void
    +показатьОтчет(): void
}
class ОтчетУспеваемости
ОтчетУспеваемости --|> Отчет
class ОтчетПосещаемости
ОтчетПосещаемости --|> Отчет

Отчет --> Курс : "создается для"
Отчет --> Журнал : "использует"

@enduml
